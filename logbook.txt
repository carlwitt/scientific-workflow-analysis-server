# Visualization server

## Session selection

A side bar or select box would be good.
> When loading the page, the newest session should be auto-selected
> Should AJAX reload the plot div on selection.
> These kinds of interactions are easy to realize with the bokeh server.
	Just add a callback that receives the newly selected session id and manipulate the data in there.


## Currently active tasks

Streaming is supported but not well documented in Bokeh. The advantage is the solution of the refresh problem (more than decreasing the load on the renderer).
Not having a smooth auto-refresh would also be o.k. but really not as cool. To poll the state, one should really just have to have a look, not refresh (always adding the wait for UI load annoyance)

> Make the server stop once the connection is closed.
	We need to make the pull client side, which is easy in principle, because we're listening to the widgets all the time anyway.
	So a refresh button works fine, but I'd like to have it automatically.
	The obvious workaround seems to be a hidden refresh button that is automatically pressed once in a while, but doing this in javascript is difficult becaue of the minified bokehjs doesn't really allow to interfere.
	 So there should be more elegant ways like adding a callback to an element that periodically calls a function that is bound to a pyhton function?

	 	var intervalID = setInterval(function(){alert("Interval reached");}, 5000);
	 	clearInterval(intervalID);

> Can't add more than one column at a time:
 	causes the renderer to get stuck. recursive loop until error?
 		This seems to be caused by calling p.line twice??
	can't access it: 2016-08-08 13:17:25,255 Error thrown from periodic callback: KeyError('diffit5',)

> Retrieve deltas from the database?
	Store last polled in visualization server state
> Can we stack the data?
	The following renders but cannot be fed a ColumnDataSource!
		Area(source.data, title="Stacked Area Chart", legend="top_left", stack=True, xlabel='time', ylabel='memory')
> Get the time axis labels straight
	Look here [http://bokeh.pydata.org/en/latest/docs/user_guide/quickstart.html#datetime-axes]
> Make plot full width
	gridplot([[p], [p2]], toolbar_location="left", plot_width=1500)
	manipulating the plot on the client side doesn't work, because it's a canvas object (changing its width will result in distorted scaling, e.g., fonts stretched)
> Since we might have many different task types, hover on the legend would be nice (since color coding will be flawed for too many task types)
> Move the legend
	According to [http://bokeh.pydata.org/en/latest/docs/user_guide/styling.html#location], this should suffice (but it doesn't)
	I guess it's the same problem as before: Gridplot overrides the settings of its components
		But removing the encapsulating gridplot element and adding the figure directly makes the problem worse. Now, none of the settings (toolbar position, legend position) take effect!
	p = figure([...])
	p.legend.location = "top_left"


+ new columns can be added via
 	source.add([0] * len(source.data["time"]), "merge")
	The docs say: "There is an implicit assumption that all the columns in a a given ColumnDataSource have the same length."
	Returning nothing is o.k.
+ Add data points: new_data is a dict that provides a list for each time series containing the new data points.
+ Render simple time series
	Using the ColumnDataSet, one can specify the data as column name in ggplot style:
	p.line(x='time', y='average', alpha=0.2, line_width=3, color='color', source=source)
+ Add a legend:	just add a legend label to the renderer
	p.line(x='time', y='merge', legend='to appear in legend', [...])
+ Remove the limit on history:
	p.x_range.follow_interval = None
	source.stream(new_data, None) # the second parameter of stream is rollover, which determines the cyclic buffer size.
+ Find a good color scheme (brewer? continuous?)
	Bokeh Palletes should suffic
	e.g.: Paired [http://bokeh.pydata.org/en/latest/docs/reference/palettes.html]



## General Information

> Find a label display element for showing (streaming, also?) the number of messages.


## Time Share

The time share visualization (percentage of cumulative compute time consumed by tasks of a type)
might not be very informative. 
	1) scientists probably know what tasks are expensive
	2) the largest share of cumulative compute time must not indicate bottlenecks,
		lowest degree of parallelism might be more interesting. Could we compute that like
		for each task, compute on average the DOP (segment by start/stop, take ratios)
		sort by descending average DOP, nice point and highlight opportunity
		=> bottleneck/sequentiality visualization